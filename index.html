<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="汤姆猫的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="汤姆猫的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>汤姆猫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">汤姆猫的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/27/oncurrentLinkedQueue%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/27/oncurrentLinkedQueue%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">ConcurrentLinkedQueue详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-27 09:59:10" itemprop="dateCreated datePublished" datetime="2020-04-27T09:59:10+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-28 23:16:02" itemprop="dateModified" datetime="2020-04-28T23:16:02+08:00">2020-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ConcurrentLinkedQueue简介"><a href="#ConcurrentLinkedQueue简介" class="headerlink" title="ConcurrentLinkedQueue简介"></a>ConcurrentLinkedQueue简介</h3><blockquote>
<p>ConcurrentLinkedQueue是一种无边界非堵塞线程安全的队列，底层通过单向链表实现，线程安全通过CAS操作实现。下图是它的类图关系，它继承了AbstractQueue类，实现Queue接口，具有Queue的基本特性。</p>
</blockquote>
<image src="/images/ConcurrentLinkedQueue.png">

<blockquote>
<p>该类内部通过两个volatile类型的Node节点来分别指向队列的首，尾节点。</p>
</blockquote>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;无参构造方法首尾分别指向item为null的哨兵节点</span><br><span class="line">public ConcurrentLinkedQueue() &#123;</span><br><span class="line">        head &#x3D; tail &#x3D; new Node&lt;E&gt;(null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据指定集合创建队列</span><br><span class="line">  public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">      Node&lt;E&gt; h &#x3D; null, t &#x3D; null;</span><br><span class="line">      for (E e : c) &#123;</span><br><span class="line">          checkNotNull(e);&#x2F;&#x2F;判断元素是否为null</span><br><span class="line">          Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);&#x2F;&#x2F;根据item创建Node·</span><br><span class="line">          if (h &#x3D;&#x3D; null)</span><br><span class="line">              h &#x3D; t &#x3D; newNode;&#x2F;&#x2F;首次插入设置首尾节点指向</span><br><span class="line">          else &#123;</span><br><span class="line">              t.lazySetNext(newNode);t的next指向新节点</span><br><span class="line">              t &#x3D; newNode;&#x2F;&#x2F;尾部节点指向新节点</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;防止指定集合为空</span><br><span class="line">      if (h &#x3D;&#x3D; null)</span><br><span class="line">          h &#x3D; t &#x3D; new Node&lt;E&gt;(null);</span><br><span class="line">      head &#x3D; h;</span><br><span class="line">      tail &#x3D; t;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="offer-入队操作"><a href="#offer-入队操作" class="headerlink" title="offer()入队操作"></a>offer()入队操作</h3><blockquote>
<p>offer()方法向队列尾部添加一个新节点，由于ConcurrentLinkedQueue是无界队列因此offer()方法放回一直是true，还有多线程是基于CAS操作因此该方法不会堵塞。方法参数不能为null，否则会抛出NPE异常。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);&#x2F;&#x2F;检测e是否为空</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);&#x2F;&#x2F;创建新节点</span><br><span class="line">			</span><br><span class="line">    &#x2F;&#x2F;从尾部开始插入</span><br><span class="line">    for (Node&lt;E&gt; t &#x3D; tail, p &#x3D; t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q &#x3D; p.next;</span><br><span class="line">        &#x2F;&#x2F;判断q是否为空，如果是则说明p为尾节点</span><br><span class="line">        if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 尝试把p的next节点指向新节点</span><br><span class="line">            if (p.casNext(null, newNode)) &#123;</span><br><span class="line"></span><br><span class="line">                if (p !&#x3D; t) &#x2F;&#x2F; </span><br><span class="line">                    casTail(t, newNode);  &#x2F;&#x2F; 尝试将尾部节点设置为新节点，失败也没事也就说法其他线程已经设置了。</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; Lost CAS race to another thread; re-read next</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p &#x3D;&#x3D; q)</span><br><span class="line">        	  &#x2F;&#x2F;为了处理poll()方法导致的。。</span><br><span class="line">            p &#x3D; (t !&#x3D; (t &#x3D; tail)) ? t : head;</span><br><span class="line">        else</span><br><span class="line">        		</span><br><span class="line">            &#x2F;&#x2F; 寻找尾部节点</span><br><span class="line">            p &#x3D; (p !&#x3D; t &amp;&amp; t !&#x3D; (t &#x3D; tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该入队方法可以分为两步:</p>
</blockquote>
<ol>
<li>定位到尾部节点：<blockquote>
<p>因为为了节省CAS操作更新tail节点的次数，所以tail并不总是尾节点，可能他的netx才是尾节点。因此在循环体中需要判断tail是否有next节点。</p>
</blockquote>
</li>
<li>通过CAS操作尝试将入队节点设置为尾节点的next节点<blockquote>
<p>p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，q如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>
</blockquote>
</li>
</ol>
<h3 id="为啥tail不总是为尾部节点"><a href="#为啥tail不总是为尾部节点" class="headerlink" title="为啥tail不总是为尾部节点"></a>为啥tail不总是为尾部节点</h3><blockquote>
<p>普通队列中总是把入队节点设置为尾部节点，在offer方法我们可以写成。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node&lt;E&gt; t &#x3D; tail;</span><br><span class="line">        </span><br><span class="line">        if (t.casNext(null ,newNode) &amp;&amp; casTail(t, newNode)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>入队节点总是尾节点，这样的代码简单易读。但是每次入队的时候都要循环设置tail节点为入队节点，影响效率。<br> · 引用:在JDK 1.7的实现中，doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。<br> 在JDK 1.8的实现中，tail的更新时机是通过p和t是否相等来判断的，其实现结果和JDK 1.7相同，即当tail节点和尾节点的距离大于等于1时，更新tail。</p>
</blockquote>
<h3 id="poll-方法出队操作"><a href="#poll-方法出队操作" class="headerlink" title="poll()方法出队操作"></a>poll()方法出队操作</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> public E poll() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h &#x3D; head, p &#x3D; h, q;;) &#123;</span><br><span class="line">            E item &#x3D; p.item;</span><br><span class="line">		&#x2F;&#x2F;item不为空和尝试设置p节点值为null</span><br><span class="line">            if (item !&#x3D; null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                &#x2F;&#x2F; Successful CAS is the linearization point</span><br><span class="line">                &#x2F;&#x2F; for item to be removed from this queue.</span><br><span class="line">                if (p !&#x3D; h) &#x2F;&#x2F; hop two nodes at a time</span><br><span class="line">                    updateHead(h, ((q &#x3D; p.next) !&#x3D; null) ? q : p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果item为空或尝试设置失败就获得p的下一个节点，如果为空则说明队列为空</span><br><span class="line">            else if ((q &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;重新开始循环</span><br><span class="line">            else if (p &#x3D;&#x3D; q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            &#x2F;&#x2F;设置p为p的下一个节点</span><br><span class="line">            else</span><br><span class="line">                p &#x3D; q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该方法的主要逻辑就是首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
</blockquote>
<h3 id="peek-方法获得头部节点"><a href="#peek-方法获得头部节点" class="headerlink" title="peek()方法获得头部节点"></a>peek()方法获得头部节点</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public E peek() &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        for (Node&lt;E&gt; h &#x3D; head, p &#x3D; h, q;;) &#123;</span><br><span class="line">            E item &#x3D; p.item;</span><br><span class="line">            if (item !&#x3D; null || (q &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                return item;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p &#x3D;&#x3D; q)</span><br><span class="line">                continue restartFromHead;</span><br><span class="line">            else</span><br><span class="line">                p &#x3D; q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获得头部节点不会弹出，执行该方法会将head节点指向第一个非空的节点</p>
</blockquote>
<h3 id="size-获得队列元素数量"><a href="#size-获得队列元素数量" class="headerlink" title="size()获得队列元素数量"></a>size()获得队列元素数量</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public int size() &#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    for (Node&lt;E&gt; p &#x3D; first(); p !&#x3D; null; p &#x3D; succ(p))</span><br><span class="line">        if (p.item !&#x3D; null)</span><br><span class="line">            &#x2F;&#x2F; Collection.size() spec says to max out</span><br><span class="line">            if (++count &#x3D;&#x3D; Integer.MAX_VALUE)</span><br><span class="line">                break;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于没有加锁，所以返回可能不准确</p>
</blockquote>
</image>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/java%E5%B8%B8%E7%94%A8%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/java%E5%B8%B8%E7%94%A8%E9%94%81/" class="post-title-link" itemprop="url">java常用锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-24 21:47:33" itemprop="dateCreated datePublished" datetime="2020-04-24T21:47:33+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-26 22:08:04" itemprop="dateModified" datetime="2020-04-26T22:08:04+08:00">2020-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="java常用锁类型"><a href="#java常用锁类型" class="headerlink" title="java常用锁类型"></a>java常用锁类型</h3><blockquote>
<p>常见的锁大致可以分为：乐观锁，悲观锁，排他锁，共享锁，分段锁，自选锁，公平锁，非公平锁等。。今天来学基于CAS非加锁实现的乐观锁</p>
</blockquote>
<h3 id="ReentrantLock锁"><a href="#ReentrantLock锁" class="headerlink" title="ReentrantLock锁"></a>ReentrantLock锁</h3><blockquote>
<p>ReentrantLock类是一种可重入，公平/非公平，独占锁，它于synchronized具有相同的功能和语义，但是它更强大，它支持中断，超时等操作。Sync是ReentrantLock的内部类，他的两个子类分别代表公平锁和非公平锁，ReentrantLock可以在构造方法选择是否公平。</p>
</blockquote>
<image src="/images/ReentrantLock.png">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"> public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lock和unlock都是基于内部类Sync实现的，因此我们了解的重点是Sync</p>
</blockquote>
<h4 id="内部类Sync"><a href="#内部类Sync" class="headerlink" title="内部类Sync"></a>内部类Sync</h4><blockquote>
<p>Sync是ReentrantLock定义的一个静态内部类，他继承了<a href="/2020/04/24/同步队列AQS">AbstractQueuedSynchronizer类</a>。它有两个实现类分别为NonfairSync(非公平锁)，FairSync(公平锁)，</p>
</blockquote>
<h5 id="非公平锁lock方法"><a href="#非公平锁lock方法" class="headerlink" title="非公平锁lock方法"></a>非公平锁lock方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    if (compareAndSetState(0, 1))&#x2F;&#x2F;尝试获得锁</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">    	  调用AQS的acquire(int arg)方法</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="公平锁lock方法"><a href="#公平锁lock方法" class="headerlink" title="公平锁lock方法"></a>公平锁lock方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">    acquire(1);&#x2F;&#x2F;直接调用AQS的acquire(int arg)方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实无论是公平或者非公平锁的lock方法最重要的就是tryAcquire(int acquires)方法</p>
</blockquote>
<h5 id="非公平锁tryAcquire-int-acquires-方法"><a href="#非公平锁tryAcquire-int-acquires-方法" class="headerlink" title="非公平锁tryAcquire(int acquires)方法"></a>非公平锁tryAcquire(int acquires)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();&#x2F;&#x2F;获得当前线程引用</span><br><span class="line">    int c &#x3D; getState();获得状态</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    	  &#x2F;&#x2F;尝试设置状态</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果当前线程为持锁线程则重入累加</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="公平锁tryAcquire-int-acquires-方法"><a href="#公平锁tryAcquire-int-acquires-方法" class="headerlink" title="公平锁tryAcquire(int acquires)方法"></a>公平锁tryAcquire(int acquires)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">		  &#x2F;&#x2F;公平锁相对于非公平锁就是多了hasQueuedPredecessors()来实现公平策略</span><br><span class="line">           final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">           int c &#x3D; getState();</span><br><span class="line">           if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">               if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc &#x3D; c + acquires;</span><br><span class="line">               if (nextc &lt; 0)</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors()"></a>hasQueuedPredecessors()</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line"></span><br><span class="line">    Node t &#x3D; tail;&#x2F;&#x2F;获得尾部节点</span><br><span class="line">    Node h &#x3D; head;&#x2F;&#x2F;获得前继节点</span><br><span class="line">    Node s;</span><br><span class="line">    return h !&#x3D; t &amp;&amp;</span><br><span class="line">        ((s &#x3D; h.next) &#x3D;&#x3D; null || s.thread !&#x3D; Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先头部节点不等于尾部节点则代表队列不为空———&gt;true<br>s为空则代表有头节点———–&gt;true<br>s不为空且s的线程不等于当前线程———&gt;true</p>
</blockquote>
<h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class TestReentrantLock &#123;</span><br><span class="line">    private static volatile ReentrantLock lock&#x3D;new ReentrantLock();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;线程一先工作呢&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(2000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程一下班啦&quot;);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(&quot;线程二在工作呢&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;线程二下班啦&quot;);</span><br><span class="line"></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-16.png" alt="upload successful"></p>
<h3 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h3><blockquote>
<p>Semaphore是一种公平/非公平锁，共享锁。它可以做为一个计数器，用来保护一个或多个锁。跟上面讲解的ReentrantLock独占锁一样，核心代码都是基于类中定义的静态内部类Sync。</p>
</blockquote>
<h5 id="acquire-方法"><a href="#acquire-方法" class="headerlink" title="acquire()方法"></a>acquire()方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);&#x2F;&#x2F;可以被中断的获锁方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从信号量获取一个许可，如果无可用许可前将一直阻塞等待。</p>
</blockquote>
<h5 id="acquireSharedInterruptibly-int-arg-方法"><a href="#acquireSharedInterruptibly-int-arg-方法" class="headerlink" title="acquireSharedInterruptibly(int arg)方法"></a>acquireSharedInterruptibly(int arg)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;如果当前线程被中断就抛出异常</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;尝试获得异常</span><br><span class="line">        doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;获锁失败放进等待队列</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tryAcquireShared-int-arg-方法"><a href="#tryAcquireShared-int-arg-方法" class="headerlink" title="tryAcquireShared(int arg)方法"></a>tryAcquireShared(int arg)方法</h5><h6 id="非公平锁实现"><a href="#非公平锁实现" class="headerlink" title="非公平锁实现"></a>非公平锁实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int available &#x3D; getState();&#x2F;&#x2F;获得可用锁数量</span><br><span class="line">        int remaining &#x3D; available - acquires;</span><br><span class="line">        &#x2F;&#x2F;如果没有锁了就直接返回否则尝试获得锁资源</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="公平锁实现"><a href="#公平锁实现" class="headerlink" title="公平锁实现"></a>公平锁实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                if (hasQueuedPredecessors())&#x2F;&#x2F;公平策略就是判断当前节点是否有前驱节点（跟上面的ReentrantLock的公平策略一样的）</span><br><span class="line">                    return -1;</span><br><span class="line">                int available &#x3D; getState();</span><br><span class="line">                int remaining &#x3D; available - acquires;</span><br><span class="line">                if (remaining &lt; 0 ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    return remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="doAcquireSharedInterruptibly-int-arg"><a href="#doAcquireSharedInterruptibly-int-arg" class="headerlink" title="doAcquireSharedInterruptibly(int arg)"></a>doAcquireSharedInterruptibly(int arg)</h5><blockquote>
<p><a href="http://localhost:4000/2020/04/24/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97AQS" target="_blank" rel="noopener">分析请见</a></p>
</blockquote>
<h4 id="release-int-arg-方法"><a href="#release-int-arg-方法" class="headerlink" title="release(int arg)方法"></a>release(int arg)方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void release() &#123;</span><br><span class="line">    sync.releaseShared(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>释放信号量中的一个许可，如果多次调用会扩大信号量的可用数量。</p>
</blockquote>
<h5 id="releaseShared-int-arg-方法"><a href="#releaseShared-int-arg-方法" class="headerlink" title="releaseShared(int arg)方法"></a>releaseShared(int arg)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg))&#x2F;&#x2F;尝试释放锁 &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryReleaseShared-int-releases-方法"><a href="#tryReleaseShared-int-releases-方法" class="headerlink" title="tryReleaseShared(int releases)方法"></a>tryReleaseShared(int releases)方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; getState();&#x2F;&#x2F;获得队列中可用锁数量</span><br><span class="line">        int next &#x3D; current + releases;</span><br><span class="line">        if (next &lt; current) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))&#x2F;&#x2F;尝试设置数量</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="doReleaseShared-方法"><a href="#doReleaseShared-方法" class="headerlink" title="doReleaseShared()方法"></a>doReleaseShared()方法</h5><blockquote>
<p><a href="http://localhost:4000/2020/04/24/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97AQS" target="_blank" rel="noopener">分析请见</a></p>
</blockquote>
</image>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/24/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97AQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/24/%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97AQS/" class="post-title-link" itemprop="url">抽象同步队列AQS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-24 12:21:43" itemprop="dateCreated datePublished" datetime="2020-04-24T12:21:43+08:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-26 12:00:54" itemprop="dateModified" datetime="2020-04-26T12:00:54+08:00">2020-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h3><blockquote>
<p>AbstractQueuedSynchronizer类简称为（AQS）,它是实现同步器的基本组件，内部使用int类型来表示同步状态，并提供CAS方法来操作这个同步状态。如常用的ReentrantLock/Semaphore/CountDownLatch等等就是基于AQS实现的，用法是通过继承AQS实现其模版方法，然后将子类作为同步组件的内部类。</p>
</blockquote>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<blockquote>
<p>上图是该类的属性，AQS是一个FIFO的双向队列，内部通过head和tail记录头部和尾部节点，队列元素为Node。当一个线程试图获得锁时，如果该锁已被占用就会新创一个Node节点把他插入到尾部。头部节点是成功获得锁的节点，当头部节点被释放的时候，会唤醒后面的节点。</p>
</blockquote>
<p><img src="/images/pasted-13.png" alt="upload successful"></p>
<blockquote>
<p>在AQS中最重要的就是对状态值state的操作，操作state的方式分为两种。</p>
</blockquote>
<ol>
<li><p>独占（Exclusive），例如ReentrantLock就是独占锁的一种。</p>
</li>
<li><p>共享（share），例如Semaphore/CountDownLatch。</p>
<blockquote>
<p>使用独占方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源， 就会标记是这个线程获取到了，其他线程再尝试操作 state 获取资源时会发现当前该资源 不是自己持有的，就会在获取失败后被阻塞。 比如独占锁 ReentrantLock 的实现， 当一个 线程获取了 Reer rantLock 的锁后，在 AQS 内 部会首先使用 CAS 操作把 state 状态值从 0 变为 1 ，然后设置当前锁的持有者为当前线程，当该线程再次获取锁时发现它就是锁的持 有者，则会把状态值从 l 变为 2，也就是设置可重入次数，而当另外一个线程获取锁时发 现自己并不是该锁的持有者就会被放入 AQS 阻塞队列后挂起。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过 CAS 方 式竞争获取资源，当一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源 还能满足它的需要，则当前线程只需要使用 CAS 方式进行获取即可。 比如 Semaphore 信 号量， 当一个线程通过 acquire（） 方法获取信号量时，会首先看当前信号量个数是否满足需 要， 不满足则把当前线程放入阻塞队列，如果满足则通过 自旋 CAS 获取信号量。</p>
</blockquote>
<blockquote>
<p>代写。。源码看晕了</p>
</blockquote>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="acquire-int-arg-独占锁方法"><a href="#acquire-int-arg-独占锁方法" class="headerlink" title="acquire(int arg)独占锁方法"></a>acquire(int arg)独占锁方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当一个线程尝试获得独占锁时，会先尝试获得锁，如果失败就将当前线程封装成Exclusive类型的Node插入AQS堵塞队列尾部，并将自己堵塞挂起。</p>
</blockquote>
<h5 id="tryAcquire-int-arg"><a href="#tryAcquire-int-arg" class="headerlink" title="tryAcquire(int arg)"></a>tryAcquire(int arg)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> tryAcquire()需要具体子类去实现的，根据所需场景设置state。</p>
</blockquote>
<h5 id="addWaiter-Node-mode"><a href="#addWaiter-Node-mode" class="headerlink" title="addWaiter(Node mode)"></a>addWaiter(Node mode)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">	    &#x2F;&#x2F;以当前节点和给定模式创建一个新节点</span><br><span class="line">        &#x2F;&#x2F;模式有：EXCLUSIVE(独占),SHARE(共享)</span><br><span class="line">        Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">        &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        Node pred &#x3D; tail;&#x2F;&#x2F;获得尾部节点</span><br><span class="line">        &#x2F;&#x2F;判断尾部节点是否为空</span><br><span class="line">        if (pred !&#x3D; null) &#123;</span><br><span class="line">            node.prev &#x3D; pred;</span><br><span class="line">            &#x2F;&#x2F;设置为尾部节点为新建节点</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next &#x3D; node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果上面失败了就进行究极自旋保证一定插入队列尾部</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>addWaiter()方法将当前线程封装成新节点插入队列尾部，并放回。</p>
</blockquote>
<h5 id="enq-final-Node-node"><a href="#enq-final-Node-node" class="headerlink" title="enq(final Node node)"></a>enq(final Node node)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">&#x2F;&#x2F;通过CAS自旋直到node成功插入队列尾部</span><br><span class="line">       for (;;) &#123;</span><br><span class="line">           Node t &#x3D; tail;&#x2F;&#x2F;获得尾部节点</span><br><span class="line">           &#x2F;&#x2F;队列为空，设置首部尾部指向新建节点</span><br><span class="line">           if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">               if (compareAndSetHead(new Node()))</span><br><span class="line">                   tail &#x3D; head;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F;正常的流程</span><br><span class="line">               node.prev &#x3D; t;</span><br><span class="line">               if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next &#x3D; node;</span><br><span class="line">                   return t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>enq()方法确保一定能将node插入队列尾部</p>
</blockquote>
<h5 id="acquireQueued-final-Node-node-int-arg"><a href="#acquireQueued-final-Node-node-int-arg" class="headerlink" title="acquireQueued(final Node node, int arg)"></a>acquireQueued(final Node node, int arg)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;&#x2F;&#x2F;标志是否拿到资源</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;&#x2F;&#x2F;标志等待时是否被中断过</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();获得前驱节点</span><br><span class="line">            &#x2F;&#x2F;如果前驱节点为头部节点，则可以尝试获得一下锁啦</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);&#x2F;&#x2F;设置当前节点为头节点</span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;shouldParkAfterFailedAcquire判断自己是否可以休息</span><br><span class="line">            &#x2F;&#x2F;parkAndCheckInterrupt让自己休眠</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在看shouldParkAfterFailedAcquire()方法前，先要了解withStatus变量。withStatus用来记录线程的等待状态可以为。</p>
</blockquote>
<ol>
<li>CANCELLED=1：表示线程因为中断或者等待超时，需要从等待队列中取消等待；</li>
<li>SIGNAL=-1：当前线程thread1占有锁，队列中的head(仅仅代表头结点，里面没有存放线程引用)的后继结点node1处于等待状态，如果已占有锁的线程thread1释放锁或被CANCEL之后就会通知这个结点node1去获取锁执行。</li>
<li>表示结点在等待队列中(这里指的是等待在某个lock的condition上，关于Condition的原理下面会写到)，当持有锁的线程调用了Condition的signal()方法之后，结点会从该condition的等待队列转移到该lock的同步队列上，去竞争lock。(注意：这里的同步队列就是我们说的AQS维护的FIFO队列，等待队列则是每个condition关联的队列)</li>
<li>表示下一次共享状态获取将会传递给后继结点获取这个共享同步状态。<br>引用：[<a href="https://www.cnblogs.com/fsmly/p/11274572.html]" target="_blank" rel="noopener">https://www.cnblogs.com/fsmly/p/11274572.html]</a><h5 id="shouldParkAfterFailedAcquire-Node-pred-Node-node"><a href="#shouldParkAfterFailedAcquire-Node-pred-Node-node" class="headerlink" title="shouldParkAfterFailedAcquire(Node pred, Node node)"></a>shouldParkAfterFailedAcquire(Node pred, Node node)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;&#x2F;&#x2F;获得前驱节点的状态</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL)&#x2F;&#x2F;判断状态是否为SIGNAL如果是就可以休眠了</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * This node has already set status asking a release</span><br><span class="line">         * to signal it, so it can safely park.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        return true;</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F;如果前端节点状态为CANCELLED,即代表放弃等待了，这时候node需要找一个在等待状态的节点，并把它做为自己的前驱节点</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">         * indicate retry.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        do &#123;</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;尝试设置前驱节点值为SIGNAL</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>shouldParkAfterFailedAcquire()方法就是设置自己的前驱节点为SIGNAL状态，这样自己才能去堵塞休眠。。</p>
</blockquote>
</li>
</ol>
<h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);&#x2F;&#x2F;将自己挂起</span><br><span class="line">    return Thread.interrupted();检测自己是否被中断过</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整体流程图如下<br>流程图片来源[<a href="https://www.cnblogs.com/zyrblog/p/9866140.html]" target="_blank" rel="noopener">https://www.cnblogs.com/zyrblog/p/9866140.html]</a><br><img src="/images/pasted-14.png" alt="upload successful"></p>
</blockquote>
<h4 id="release-int-arg-独占锁释放方法"><a href="#release-int-arg-独占锁释放方法" class="headerlink" title="release(int arg)独占锁释放方法"></a>release(int arg)独占锁释放方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	  &#x2F;&#x2F;尝试释放锁，这里一般都会成功因为独占，一般都是拿到锁的才去释放。。</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);&#x2F;&#x2F;唤醒等待队列的下一个节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tryRelease-int-arg"><a href="#tryRelease-int-arg" class="headerlink" title="tryRelease(int arg)"></a>tryRelease(int arg)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryRelease(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里一样需要具体子类去实现</p>
</blockquote>
<h5 id="unparkSuccessor-Node-node"><a href="#unparkSuccessor-Node-node" class="headerlink" title="unparkSuccessor(Node node)"></a>unparkSuccessor(Node node)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);&#x2F;&#x2F;尝试将当前节点设为0</span><br><span class="line"></span><br><span class="line">    Node s &#x3D; node.next;获得要唤醒的下一个节点</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;&#x2F;&#x2F;如果为空或取消</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F;遍历找出有效节点</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F;唤醒</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/pasted-15.png" alt="upload successful"></p>
<h4 id="acquireShared-int-arg-共享锁方法"><a href="#acquireShared-int-arg-共享锁方法" class="headerlink" title="acquireShared(int arg)共享锁方法"></a>acquireShared(int arg)共享锁方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    &#x2F;&#x2F;尝试获得锁</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="tryAcquireShared-int-arg"><a href="#tryAcquireShared-int-arg" class="headerlink" title="tryAcquireShared(int arg)"></a>tryAcquireShared(int arg)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的tryAcquireShared(int arg)方法一样需要具体子类去实现，根据所需场景自定义状态设置，和结果返回。</p>
</blockquote>
<h5 id="doAcquireShared-int-arg"><a href="#doAcquireShared-int-arg" class="headerlink" title="doAcquireShared(int arg)"></a>doAcquireShared(int arg)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;这里一样通过究极自旋操作保证把新建节点插入队列尾部</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;&#x2F;&#x2F;中断标志</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();&#x2F;&#x2F;获得前驱节点</span><br><span class="line">            &#x2F;&#x2F;如果head为node的前驱节点，那很有可能就是被head释放锁唤醒的</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);&#x2F;&#x2F;尝试获得锁</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);&#x2F;&#x2F;设置头部和尝试唤醒其他线程</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    if (interrupted)&#x2F;&#x2F;如果被中断过现在中断自己</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed &#x3D; false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;跟独占一样，寻找安全点休眠并尝试获得锁</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="setHeadAndPropagate-Node-node-int-propagate"><a href="#setHeadAndPropagate-Node-node-int-propagate" class="headerlink" title="setHeadAndPropagate(Node node, int propagate)"></a>setHeadAndPropagate(Node node, int propagate)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F;获得头部</span><br><span class="line">    setHead(node);&#x2F;&#x2F;设置头部</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F;唤醒后续堵塞节点</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="releaseShared-int-arg-共享锁释放"><a href="#releaseShared-int-arg-共享锁释放" class="headerlink" title="releaseShared(int arg)共享锁释放"></a>releaseShared(int arg)共享锁释放</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="tryReleaseShared-int-arg"><a href="#tryReleaseShared-int-arg" class="headerlink" title="tryReleaseShared(int arg)"></a>tryReleaseShared(int arg)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryReleaseShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一样由具体子类重写</p>
</blockquote>
<h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                &#x2F;&#x2F; loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/23/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E7%B1%BB/" class="post-title-link" itemprop="url">原子变量操作类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-23 14:55:15 / Modified: 15:57:54" itemprop="dateCreated datePublished" datetime="2020-04-23T14:55:15+08:00">2020-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="JUC简介"><a href="#JUC简介" class="headerlink" title="JUC简介"></a>JUC简介</h3><blockquote>
<p>在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p>
</blockquote>
<blockquote>
<p>在JUC并发包中包含有AtomicInteger，AtomicLong,AtomicBoolean等基于CAS操作的原子操作类。他们原理相似，下面讲解AtomicLong类。它可以原子性递增或递减，内部通过Unsafe来实现。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicLong extends Number implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1927816293512124184L;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获得Unsafe实例</span><br><span class="line">    private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;获得long值偏移量</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">	  &#x2F;&#x2F;判断JVM是否支持Long类型的无锁CAS操作</span><br><span class="line">    static final boolean VM_SUPPORTS_LONG_CAS &#x3D; VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;本地方法。。</span><br><span class="line">    private static native boolean VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;静态代码块</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            获得偏移量</span><br><span class="line">            valueOffset &#x3D; unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;实际值</span><br><span class="line">    private volatile long value;</span><br><span class="line"></span><br><span class="line">    public AtomicLong(long initialValue) &#123;</span><br><span class="line">        value &#x3D; initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AtomicLong() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><blockquote>
<p>在jdk中提供了Unsafe类来实现CAS操作，该类中的所有方法都是本地方法（Native），下面是Unsafe几个重要方法</p>
</blockquote>
<blockquote>
<p>long object FieldOffset(Field field)方法, 负责获得指定变量在所属类中的内存偏移量，该偏移量只能在Unsafe方法中访问指定函数才能使用</p>
</blockquote>
<blockquote>
<p>long native getLongVolatile(Object obj,long offset)方法，负责获得对象obj中指定偏移量offset的变量所对应的值</p>
</blockquote>
<h3 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h3><h4 id="递增递减操作"><a href="#递增递减操作" class="headerlink" title="递增递减操作"></a>递增递减操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获得递增后的值</span><br><span class="line">  public final long incrementAndGet() &#123;</span><br><span class="line">      return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获得递减后的值</span><br><span class="line">  public final long decrementAndGet() &#123;</span><br><span class="line">      return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;获得递增前的值</span><br><span class="line">  public final long getAndIncrement() &#123;</span><br><span class="line">      return unsafe.getAndAddLong(this, valueOffset, 1L);</span><br><span class="line">  &#125;</span><br><span class="line">  获得递减前的值</span><br><span class="line">  public final long getAndDecrement() &#123;</span><br><span class="line">      return unsafe.getAndAddLong(this, valueOffset, -1L);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的递增递减操作都是调用了Unsafe的getAndAddLong()方法来实现的,该函数时原子性操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;参数一代表AtomicLong实例的引用，</span><br><span class="line">&#x2F;&#x2F;参数二代表AtomicLong的value变量的偏移量</span><br><span class="line">&#x2F;&#x2F;参数三代表要改变的值</span><br><span class="line">public final long getAndAddLong(Object var1, long var2, long var4) &#123;</span><br><span class="line">    long var6;</span><br><span class="line">    do &#123;</span><br><span class="line">        var6 &#x3D; this.getLongVolatile(var1, var2);&#x2F;&#x2F;获得初始值</span><br><span class="line">        &#x2F;&#x2F;如果获得的初始值不相等则继续循环直到相等</span><br><span class="line">    &#125; while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">    return var6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class TestAtomic &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            Thread thread&#x3D;new Thread(new CountThread(),&quot;线程&quot;+i);</span><br><span class="line">            thread.start();</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(CountThread.value);</span><br><span class="line">    &#125;</span><br><span class="line">    public static class CountThread implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        public static AtomicLong value&#x3D;new AtomicLong();</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i&#x3D;0;i&lt;1000;i++)&#123;</span><br><span class="line">                value.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>在没有原子类的情况下，要实现多线程计数器需要同步措施，例如使用synchronized关键字，但这会大大影响性能，而这些Atomic原子类实现了CAS非堵塞算法，提升了性能。不过在高并发的情况下还是会影响性能，在JDK8中提供了在高并发性能更好的LongAdder类，下次再来写了。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/23/synchronized%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/23/synchronized%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">synchronized和volatile关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-23 09:59:21 / Modified: 11:09:39" itemprop="dateCreated datePublished" datetime="2020-04-23T09:59:21+08:00">2020-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><blockquote>
<p>java内存模型规定，将所有的变量都放在主内存，当线程使用变量时，会把该变量复制到线程的工作内存，因此线程读写变量操作的是自己工作内存中的变量。</p>
</blockquote>
<p><img src="/images/pasted-7.png" alt="upload successful"></p>
<blockquote>
<p>下图是一个双核cpu的系统架构，每个核都有自己的控制器、运算器、一级缓存，其中控制器包含一组寄存器和操作控制器，运算器负责进行算术逻辑运算。在这个架构中cpu还共享一个二级缓存。</p>
</blockquote>
<blockquote>
<p>其中java内存模型里的线程工作内存对应就是一级缓存、二级缓存、cpu寄存器</p>
</blockquote>
<p><img src="/images/pasted-8.png" alt="upload successful"></p>
<h3 id="共享对象可见性"><a href="#共享对象可见性" class="headerlink" title="共享对象可见性"></a>共享对象可见性</h3><blockquote>
<p>例如上图，假设线程A和线程B同时处理一个共享变量，且线程使用不同cpu运行，缓存都为空。<br> 线程 A 首先获取共享变量 X 的值，由于两级 Cache 都没有命中 ，所以加载主 内存 中 X 的值，假如为 0。然后把 X=O 的值缓存到两级缓存， 线程 A 修改 X 的值为 1, 然后将其写入两级 Cache， 并且刷新到主内存。 线程 A 操作完毕后，线程 A 所在的 CPU 的两级 Cache 内和主内存里面的 X 的值都是 l 。<br> 线程 B 获取 X 的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了 ， 所以返回 X= 1 ； 到这里一切都是正常的， 因为这时候主 内存中也是 X=l 。然后线 程 B 修改 X 的值为 2， 并将其存放到线程 2 所在的一级 Cache 和共享二级 Cache 中， 最后更新主内存中 X 的值为 2 ： 到这里一切都是好的。<br> 线程 A 这次又需要修改 X 的值， 获取时一级缓存命中， 并且 X=l ，到这里问题就 出 现了，明明线程 B 已经把 X 的值修改为了 2，为何线程 A 获取的还是 l 呢？ 这 就是共享变量的内存不可见问题， 也就是线程 B 写入的值对线程 A 不可见。（来自于《java并发编程之美》）</p>
</blockquote>
<blockquote>
<p>使用synchronized和volatile关键字可以解决共享对象的不可见性</p>
</blockquote>
<h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><blockquote>
<p>synchronized关键字是java提供的一个原子性内置锁（排他锁），同一时间最多只能有一个线程持有相同对象的锁。在线程进入synchronizedd代码块会获得对象锁，其他线程运行到synchronized会被堵塞挂起。<br>拿到对象锁的线程会在以下情况释放对象锁：<br>1.正常执行完同步代码块。<br>2.抛出异常。<br>3.调用wait等休眠方法</p>
</blockquote>
<h4 id="synchronized的内存语义"><a href="#synchronized的内存语义" class="headerlink" title="synchronized的内存语义"></a>synchronized的内存语义</h4><blockquote>
<p>进入synchronized代码块会把同步代码块用到的变量从运行线程的工作内存中清除。这样获取变量时就不会从工作内存中获得，而是去主内存中获得。<br>退出synchronized代码块会把对同步代码块修改的变量刷新到主内存里去。</p>
</blockquote>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><blockquote>
<p>当一个变量被volatile关键字声明时，工作线程获取该变量时会直接从主内存中获得，修改变量值会直接把值刷新到主内存中去。</p>
</blockquote>
<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><blockquote>
<p>同：synchronized和volatile都可以实现在多线程中共享对象的可见性。<br>异：volatile只保证共享对象的可见性，不保证操作的原子性。<br>   synchronized是比较重量级的操作，他会引起线程上下文的切换并带来线程调度开销。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/21/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/21/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">线程基本概念和操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-21 22:49:06" itemprop="dateCreated datePublished" datetime="2020-04-21T22:49:06+08:00">2020-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-22 22:18:33" itemprop="dateModified" datetime="2020-04-22T22:18:33+08:00">2020-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h3><blockquote>
<p>首先我们要先了解进程的基本概念，因为线程是进程中的一个实体。进程是操作系统中进行资源调度和调度的基本单位，线程则是进程的一个执行路径。</p>
</blockquote>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<blockquote>
<p>一个进程中包含多个线程，多个线程共享进程的堆和方法区资源，每个线程有独立的程序计数器和栈区域。</p>
</blockquote>
<h3 id="线程的三种创建方式"><a href="#线程的三种创建方式" class="headerlink" title="线程的三种创建方式"></a>线程的三种创建方式</h3><h4 id="类继承Thread"><a href="#类继承Thread" class="headerlink" title="类继承Thread"></a>类继承Thread</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestNewThread &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyThread extends Thread&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new MyThread().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类实现Runnable接口"><a href="#类实现Runnable接口" class="headerlink" title="类实现Runnable接口"></a>类实现Runnable接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestNewThread &#123;</span><br><span class="line"></span><br><span class="line">    public static class RunnableImpl implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new RunnableImpl()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类实现Callable接口-使用FutureTask方式"><a href="#类实现Callable接口-使用FutureTask方式" class="headerlink" title="类实现Callable接口,使用FutureTask方式"></a>类实现Callable接口,使用FutureTask方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class TestNewThread &#123;</span><br><span class="line"></span><br><span class="line">    public static class CallableImpl implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            return &quot;Hello World&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;*new MyThread().run();*&#x2F;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask&#x3D;new FutureTask&lt;&gt;(new CallableImpl());</span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三种方式优劣"><a href="#三种方式优劣" class="headerlink" title="三种方式优劣"></a>三种方式优劣</h4><h5 id="1-使用继承方式"><a href="#1-使用继承方式" class="headerlink" title="1.使用继承方式"></a>1.使用继承方式</h5><blockquote>
<p>优势：<br>编写简单，传参方便，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。<br>劣势：无法在继承其他父类</p>
</blockquote>
<h5 id="2-实现Runnable接口方式和Callable接口"><a href="#2-实现Runnable接口方式和Callable接口" class="headerlink" title="2.实现Runnable接口方式和Callable接口"></a>2.实现Runnable接口方式和Callable接口</h5><blockquote>
<p>优势：<br>程类只是实现了Runnable接口或Callable接口，还可以继承其他类。<br>在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况。<br>callable还可以拿到线程的返回值<br>劣势：编写稍微稍微复杂点？</p>
</blockquote>
<h3 id="线程的休眠和等待"><a href="#线程的休眠和等待" class="headerlink" title="线程的休眠和等待"></a>线程的休眠和等待</h3><h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h4><blockquote>
<p>在java所有类的直接或间接父类Object类中有个wait(),当调用时会让当前线程堵塞挂起。</p>
</blockquote>
<blockquote>
<p>注意：调用对象的wait()时，要确保获得对象的监视器锁。</p>
</blockquote>
<h5 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadWait &#123;</span><br><span class="line">    private static Object lock&#x3D;new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            System.out.println(&quot;🔒前&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;🔒后&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<blockquote>
<p>那么怎么获得对象监视器锁呢<br>1.执行synchronized同步代码块时，并且使用该对象做为锁</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       synchronized(lock) &#123;</span><br><span class="line">&#x2F;&#x2F;doSomething</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.调用对象的synchronizeed方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">       &#x2F;&#x2F;doSomething </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h4><blockquote>
<p>sleep()是Thread线程类的一个静态方法，执行时当前线程会暂时让出对cpu的执行权，但是注意休眠的时候不会退出锁（线程所拥有的监视器资源）。当休眠时间到了就会继续正常运行，当还在休眠时间时，调用该休眠线程的interrupt()方法时，该休眠线程就会在调用sleep()方法的地方抛出InterruptedException异常返回。</p>
</blockquote>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadWait &#123;</span><br><span class="line">    private static Object lock&#x3D;new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                System.out.println(&quot;线程一休眠前&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程一休眠后&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                System.out.println(&quot;线程二休眠前&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程二休眠后&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="/images/pasted-5.png" alt="upload successful"></p>
<h3 id="线程通知"><a href="#线程通知" class="headerlink" title="线程通知"></a>线程通知</h3><h4 id="notify-方法和notifyAll-方法"><a href="#notify-方法和notifyAll-方法" class="headerlink" title="notify()方法和notifyAll()方法"></a>notify()方法和notifyAll()方法</h4><blockquote>
<p>执行notify/notifyAll方法会唤醒一个/多个正处于休眠状态的线程。然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。<br>类似wait方法，当前线程获取到对象的锁(监视器资源)才可以执行notify/notifyAll方法,否则会抛出异常。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class TestThreadWait &#123;</span><br><span class="line">    private static Object lock&#x3D;new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                System.out.println(&quot;线程一休眠前&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程一休眠后&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(()-&gt;&#123;</span><br><span class="line">            synchronized(lock) &#123;</span><br><span class="line">                System.out.println(&quot;尝试换线休眠线程&quot;);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;唤醒完毕&quot;);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><p><img src="/images/pasted-6.png" alt="upload successful"></p>
<h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><blockquote>
<p>这时候线程已被初始化，不过还没有运行。</p>
</blockquote>
<h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><blockquote>
<p>运行状态，Java线程把操作系统中的就绪和运行两种状态统一称为“运行中”。</p>
</blockquote>
<h4 id="TERMINATD"><a href="#TERMINATD" class="headerlink" title="TERMINATD"></a>TERMINATD</h4><blockquote>
<p>线程结束状态。</p>
</blockquote>
<h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h4><blockquote>
<p>线程堵塞状态，等待获取监视器资源进入同步方法或同步代码块。</p>
</blockquote>
<h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><blockquote>
<p>线程等待状态，等待其他线程，调用Object.wait(),Thread.join()等方法会进入等待状态。</p>
</blockquote>
<h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><blockquote>
<p>线程等待一段时间状态,调用Thread.sleep(Long millis)等会进入等待一段时间状态。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/20/java%E9%9B%86%E5%90%88-HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/java%E9%9B%86%E5%90%88-HashMap/" class="post-title-link" itemprop="url">java集合-HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 22:45:06" itemprop="dateCreated datePublished" datetime="2020-04-20T22:45:06+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-21 15:19:26" itemprop="dateModified" datetime="2020-04-21T15:19:26+08:00">2020-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h3><blockquote>
<p>HashMap用来存放键值对，它基于哈希表的Map非同步接口实现，它继承了AbstractMap，实现了Map,Cloneable,Serializable等接口。</p>
</blockquote>
<blockquote>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间，具体可以参考 treeifyBin方法。</p>
</blockquote>
<h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    &#x2F;&#x2F; 序列号</span><br><span class="line">    private static final long serialVersionUID &#x3D; 362498820763181265L;    </span><br><span class="line">    &#x2F;&#x2F; 默认的初始容量是16</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;   </span><br><span class="line">    &#x2F;&#x2F; 最大容量</span><br><span class="line">    static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30; </span><br><span class="line">    &#x2F;&#x2F; 默认的填充因子</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line">    &#x2F;&#x2F; 当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">    static final int TREEIFY_THRESHOLD &#x3D; 8; </span><br><span class="line">    &#x2F;&#x2F; 当桶(bucket)上的结点数小于这个值时树转链表</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line">    &#x2F;&#x2F; 桶中结构转化为红黑树对应的table的最小大小</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br><span class="line">    &#x2F;&#x2F; 存储元素的数组，总是2的幂次倍</span><br><span class="line">    transient Node&lt;k,v&gt;[] table; </span><br><span class="line">    &#x2F;&#x2F; 存放具体元素的集</span><br><span class="line">    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    &#x2F;&#x2F; 存放元素的个数，注意这个不等于数组的长度。</span><br><span class="line">    transient int size;</span><br><span class="line">    &#x2F;&#x2F; 每次扩容和更改map结构的计数器</span><br><span class="line">    transient int modCount;   </span><br><span class="line">    &#x2F;&#x2F; 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span><br><span class="line">    int threshold;</span><br><span class="line">    &#x2F;&#x2F; 加载因子</span><br><span class="line">    final float loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="loadFactor负载因子"><a href="#loadFactor负载因子" class="headerlink" title="loadFactor负载因子"></a>loadFactor负载因子</h5><blockquote>
<p>  loadFactor是用来控制存放元素数组的疏密程度，当loadFactor越大，数组存放的entry也就越多，也会让链表的长度变长，当loadFactor越小，数组存放的entry也就越少。<br>    loadFactory太大会导致查询效率变慢，太小会浪费内存空间。</p>
</blockquote>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据指定的初始化容量和负载因子创建对象</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定初始化容量，负载因子默认为0.75</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据指定的map集合创建对象</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F;判断table是否未初始化或长度为0，如果是就扩容</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F;确定元素放在那个桶，如果桶为空则直接插入</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F;判断哈希，键是否相等</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;后面进行覆盖</span><br><span class="line">        &#x2F;&#x2F;判断节点是否为红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">        	  &#x2F;&#x2F;存放进红黑树中</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F;循环遍历链表</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F;插入链表的尾部</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F;判断是否要将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;判断节点的hash和key是否相等</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果e不为空，则是进行覆盖操作</span><br><span class="line">        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();&#x2F;&#x2F;扩容</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    &#x2F;&#x2F;判断哈希表是否为空，长度是否大于0，hash值对应的桶是否为空</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;判断hash，key是否相等</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;&#x2F;&#x2F;返回节点</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">        	  &#x2F;&#x2F;判断是否为红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                &#x2F;&#x2F;红黑树查找</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            do &#123;</span><br><span class="line">                &#x2F;&#x2F;链表遍历查找</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>resize方法待写。。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/19/java%E9%9B%86%E5%90%88-LinkedList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/19/java%E9%9B%86%E5%90%88-LinkedList/" class="post-title-link" itemprop="url">java集合-LinkedList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-19 11:31:19" itemprop="dateCreated datePublished" datetime="2020-04-19T11:31:19+08:00">2020-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-20 11:16:18" itemprop="dateModified" datetime="2020-04-20T11:16:18+08:00">2020-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="LinkedList简介"><a href="#LinkedList简介" class="headerlink" title="LinkedList简介"></a>LinkedList简介</h3><blockquote>
<p>LinkedList数据结构是双端链表，所以它支持高效的插入和删除操作，继承于AbstractSequentialList,实现了Serializable,List,Deque,Cloneable等接口</p>
</blockquote>
<blockquote>
<p>LinkedList继承AbstrctSequentialList，实现了List接口，他是一个链表队列，提供了相关的添加，删除，插入，遍历等操作</p>
</blockquote>
<blockquote>
<p>LinkedList实现了Deque接口，拥有部分队列的性质，例如可以在两端插入和删除元素</p>
</blockquote>
<blockquote>
<p>LinkedList实现了Cloneable接口，表示覆盖了clone（）方法，能被克隆。</p>
</blockquote>
<blockquote>
<p>LinkedList实现了Serializable接口,表示该类能够被序列化来传输。</p>
</blockquote>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<blockquote>
<p>LinkedList类中的静态内部类Node便是用来充当链表中的节点功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">      E item;&#x2F;&#x2F;元素数据</span><br><span class="line">      Node&lt;E&gt; next;&#x2F;&#x2F;后继节点</span><br><span class="line">      Node&lt;E&gt; prev;&#x2F;&#x2F;前驱节点</span><br><span class="line"></span><br><span class="line">      Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">          this.item &#x3D; element;</span><br><span class="line">          this.next &#x3D; next;</span><br><span class="line">          this.prev &#x3D; prev;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;无参构造方法</span><br><span class="line"> public LinkedList() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 根据指定集合创建链表</span><br><span class="line"> * @param  c the collection whose elements are to be placed into this list</span><br><span class="line"> * @throws NullPointerException if the specified collection is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);&#x2F;&#x2F;插入链表尾部</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);&#x2F;&#x2F;新建节点</span><br><span class="line">    last &#x3D; newNode;&#x2F;&#x2F;尾部指向新建节点</span><br><span class="line">    if (l &#x3D;&#x3D; null)&#x2F;&#x2F;如果尾部节点为空，则代表当前链表元素为空</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;指向新建的节点</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在指定位置插入的add方法"><a href="#在指定位置插入的add方法" class="headerlink" title="在指定位置插入的add方法"></a>在指定位置插入的add方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);&#x2F;&#x2F;检查下标范围</span><br><span class="line">    if (index &#x3D;&#x3D; size)&#x2F;&#x2F;判断下标值</span><br><span class="line">        linkLast(element);&#x2F;&#x2F;插入尾部（上面讲过了）</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));&#x2F;&#x2F;插入指定位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">       &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line">		&#x2F;&#x2F;判断下标是否小于链表大小&#x2F;2</span><br><span class="line">       &#x2F;&#x2F;这里对半查询</span><br><span class="line">       &#x2F;&#x2F;size&gt;&gt;1&#x3D;&#x3D;size&#x2F;2</span><br><span class="line">       if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">           Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">               x &#x3D; x.next;</span><br><span class="line">           return x;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">           for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">               x &#x3D; x.prev;</span><br><span class="line">           return x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">    final Node&lt;E&gt; pred &#x3D; succ.prev;获得原位置节点的前驱节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);&#x2F;&#x2F;创建新节点</span><br><span class="line">    succ.prev &#x3D; newNode;原位置节点的前驱节点指向新节点</span><br><span class="line">    if (pred &#x3D;&#x3D; null)&#x2F;&#x2F;判断是否为头节点</span><br><span class="line">        first &#x3D; newNode;头节点指向新节点</span><br><span class="line">    else</span><br><span class="line">        pred.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addAll方法"><a href="#addAll方法" class="headerlink" title="addAll方法"></a>addAll方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    return addAll(size, c);&#x2F;&#x2F;尾部批量插入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定位置的addAll方法"><a href="#指定位置的addAll方法" class="headerlink" title="指定位置的addAll方法"></a>指定位置的addAll方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">      checkPositionIndex(index);&#x2F;&#x2F;检测下标范围</span><br><span class="line"></span><br><span class="line">      Object[] a &#x3D; c.toArray();&#x2F;&#x2F;集合转换为数组</span><br><span class="line">      int numNew &#x3D; a.length;</span><br><span class="line">      if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">          return false;</span><br><span class="line"></span><br><span class="line">      Node&lt;E&gt; pred, succ;</span><br><span class="line">      if (index &#x3D;&#x3D; size)&#123;&#x2F;&#x2F;判断下标长度是否等于链表长度，即插入尾部</span><br><span class="line">          succ &#x3D; null;</span><br><span class="line">          pred &#x3D; last;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          succ &#x3D; node(index);</span><br><span class="line">          pred &#x3D; succ.prev;</span><br><span class="line">      &#125;</span><br><span class="line">	&#x2F;&#x2F;循环遍历指定数组</span><br><span class="line">      for (Object o : a) &#123;</span><br><span class="line">          @SuppressWarnings(&quot;unchecked&quot;) E e &#x3D; (E) o;</span><br><span class="line">          Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">          if (pred &#x3D;&#x3D; null)</span><br><span class="line">              first &#x3D; newNode;</span><br><span class="line">          else</span><br><span class="line">              pred.next &#x3D; newNode;</span><br><span class="line">          pred &#x3D; newNode;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">          last &#x3D; pred;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          pred.next &#x3D; succ;</span><br><span class="line">          succ.prev &#x3D; pred;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      size +&#x3D; numNew;</span><br><span class="line">      modCount++;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除指定元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">            for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">                if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">                if (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">        final E element &#x3D; x.item;&#x2F;&#x2F;获得要删除元素的值</span><br><span class="line">        final Node&lt;E&gt; next &#x3D; x.next;&#x2F;&#x2F;获得要删除元素的后继节点</span><br><span class="line">        final Node&lt;E&gt; prev &#x3D; x.prev;&#x2F;&#x2F;获得要删除元素的前驱节点</span><br><span class="line">        &#x2F;&#x2F;判断前驱节点是否为空</span><br><span class="line">        if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">            first &#x3D; next;&#x2F;&#x2F;把头指针指向后继节点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next &#x3D; next;&#x2F;&#x2F;前驱节点的后继节点指向x的后继节点</span><br><span class="line">            x.prev &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">			&#x2F;&#x2F;判断后继节点是否为空</span><br><span class="line">        if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">            last &#x3D; prev;&#x2F;&#x2F;把尾指针指向前驱节点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev &#x3D; prev;&#x2F;&#x2F;后继节点的前驱节点指向x的前驱节点</span><br><span class="line">            x.next &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item &#x3D; null;</span><br><span class="line">        size--;长度减一</span><br><span class="line">        modCount++;</span><br><span class="line">        return element;返回x数据</span><br><span class="line">    &#125;</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>
<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;上面都讲过了。。</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        return node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="ArrayList和LinkedList的区别，使用场景"><a href="#ArrayList和LinkedList的区别，使用场景" class="headerlink" title="ArrayList和LinkedList的区别，使用场景"></a>ArrayList和LinkedList的区别，使用场景</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><blockquote>
<p>1.ArrayList和LinkedList的区别就来自于他们的底层数据结构，ArrayList是基于数组实现的，因此它随机遍历会很快，LinkedList是基于双端链表，因此它插入删除会很快。</p>
</blockquote>
<blockquote>
<p>2.相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</p>
</blockquote>
<blockquote>
<p>3.存储同样数据的LinkedList相对于ArrayList会占用更多内存，因为LinkedList还要存储前驱节点和后驱节点的位置。</p>
</blockquote>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><blockquote>
<p>1.在需要大量的随机访问，使用ArrayList优于LinkedList</p>
</blockquote>
<blockquote>
<p>2.在需要大量的插入和删除操作时，使用LinkedList优于ArrayList</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/java%E9%9B%86%E5%90%88-ArrayList-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/java%E9%9B%86%E5%90%88-ArrayList-1/" class="post-title-link" itemprop="url">java集合-ArrayList</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-18 19:31:03 / Modified: 23:43:41" itemprop="dateCreated datePublished" datetime="2020-04-18T19:31:03+08:00">2020-04-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88/" itemprop="url" rel="index"><span itemprop="name">集合</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h3><blockquote>
<p>ArrayList数据结构是基于数组，与java原本数组不一样的是它能够动态增长，继承于AbstractList,实现了List,Serializable,RandomAccess,Cloneable等接口。</p>
</blockquote>
<blockquote>
<p>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</p>
</blockquote>
<blockquote>
<p>ArrayList实现了Cloneable接口，表示覆盖了clone（）方法，能被克隆。</p>
</blockquote>
<blockquote>
<p>ArrayList实现了Serializable接口,表示该类能够被序列化来传输</p>
</blockquote>
<blockquote>
<p>ArrayList实现了RandomAccess接口,RandomAccess接口是一个标识接口，表示该类支持快速随机访问。另外：”根据官方说法被该接口标识的类使用for循环来遍历要优于迭代器来遍历”</p>
</blockquote>
<img src="/images/pasted-2.png">


<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package java.util;</span><br><span class="line"></span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line">import java.util.function.UnaryOperator;</span><br><span class="line">import sun.misc.SharedSecrets;</span><br><span class="line"></span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 8683452581122892189L;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 默认初始化容量.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 空数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;用于默认大小空实例的共享空数组实例。</span><br><span class="line">      &#x2F;&#x2F;我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br><span class="line">    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	  &#x2F;&#x2F;用于保存ArrayList数据的数组</span><br><span class="line">     &#x2F;&#x2F;这里用了transient关键字来表示该数组不被序列化，在这里是为了避免java自带的序列化操作，并定义了两个方法，实现自定的序列化操作。</span><br><span class="line">      </span><br><span class="line">    transient Object[] elementData; &#x2F;&#x2F; non-private to simplify nested class access</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">     * 当前元素个数</span><br><span class="line">     * @serial</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private int size;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/yingfeng612/article/details/79813484" target="_blank" rel="noopener">ArrayList中的数组为什么被transient修饰</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;**</span><br><span class="line">    * 带初始化容量的构造方法</span><br><span class="line">    * </span><br><span class="line">    * @param  initialCapacity  the initial capacity of the list</span><br><span class="line">    * @throws IllegalArgumentException if the specified initial capacity</span><br><span class="line">    *         is negative</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ArrayList(int initialCapacity) &#123;</span><br><span class="line">       if (initialCapacity &gt; 0) &#123;</span><br><span class="line">           this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">       &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">       &#x2F;&#x2F;创建空数组</span><br><span class="line">           this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 默认构造函数，DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ArrayList() &#123;</span><br><span class="line">       this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 按照指定集合的迭代器返回的顺序创建数组元素</span><br><span class="line">    *</span><br><span class="line">    * @param c the collection whose elements are to be placed into this list</span><br><span class="line">    * @throws NullPointerException if the specified collection is null</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       elementData &#x3D; c.toArray();</span><br><span class="line">       if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;</span><br><span class="line">           &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">           if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">               elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           &#x2F;&#x2F; replace with empty array.</span><br><span class="line">           this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="line">    * the storage of an &lt;tt&gt;ArrayList&lt;&#x2F;tt&gt; instance.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void trimToSize() &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       if (size &lt; elementData.length) &#123;</span><br><span class="line">           elementData &#x3D; (size &#x3D;&#x3D; 0)</span><br><span class="line">             ? EMPTY_ELEMENTDATA</span><br><span class="line">             : Arrays.copyOf(elementData, size);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 不懂这做啥的。。。</span><br><span class="line">    * @param   minCapacity   the desired minimum capacity</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">       int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">           &#x2F;&#x2F; any size if not default element table</span><br><span class="line">           ? 0</span><br><span class="line">           &#x2F;&#x2F; larger than default for default empty table. It&#39;s already</span><br><span class="line">           &#x2F;&#x2F; supposed to be at default size.</span><br><span class="line">           : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">       if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">           ensureExplicitCapacity(minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;计算扩容的大小</span><br><span class="line">   private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;</span><br><span class="line">   &#x2F;&#x2F;如果数组元素是空数组就返回最大值</span><br><span class="line">       if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">           return Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       return minCapacity;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">       ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;扩容主要的方法</span><br><span class="line">   private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">           grow(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * The maximum size of array to allocate.</span><br><span class="line">    * Some VMs reserve some header words in an array.</span><br><span class="line">    * Attempts to allocate larger arrays may result in</span><br><span class="line">    * OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALUE - 8;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 扩容的核心办法</span><br><span class="line">    * @param minCapacity the desired minimum capacity</span><br><span class="line">    *&#x2F;</span><br><span class="line">    </span><br><span class="line">   private void grow(int minCapacity) &#123;</span><br><span class="line">       &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">       &#x2F;&#x2F;获得旧数组大小</span><br><span class="line">       int oldCapacity &#x3D; elementData.length;</span><br><span class="line">       &#x2F;&#x2F;获得旧数组大小1.5倍</span><br><span class="line">       int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">       if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">           newCapacity &#x3D; minCapacity;</span><br><span class="line">       &#x2F;&#x2F;检查扩容的大小是否还小于最小需求的容量</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">           newCapacity &#x3D; hugeCapacity(minCapacity);	</span><br><span class="line">       &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:</span><br><span class="line">       elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">       if (minCapacity &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">           throw new OutOfMemoryError();</span><br><span class="line">       return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">           Integer.MAX_VALUE :</span><br><span class="line">           MAX_ARRAY_SIZE;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回数组元素个数</span><br><span class="line">    *</span><br><span class="line">    * @return the number of elements in this list</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int size() &#123;</span><br><span class="line">       return size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 判空</span><br><span class="line">    *</span><br><span class="line">    * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if this list contains no elements</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean isEmpty() &#123;</span><br><span class="line">       return size &#x3D;&#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 判断指定元素是否存在数组元素中</span><br><span class="line">    * @param o element whose presence in this list is to be tested</span><br><span class="line">    * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if this list contains the specified element</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean contains(Object o) &#123;</span><br><span class="line">       return indexOf(o) &gt;&#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回指定元素在数组的首次出现的索引，如果不包含就返回-1</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int indexOf(Object o) &#123;</span><br><span class="line">       if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">               if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                   return i;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">               if (o.equals(elementData[i]))</span><br><span class="line">                   return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回指定元素在数组的最后出现的索引，如果不包含就返回-1</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int lastIndexOf(Object o) &#123;</span><br><span class="line">       if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">           for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">               if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                   return i;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">               if (o.equals(elementData[i]))</span><br><span class="line">                   return i;</span><br><span class="line">       &#125;</span><br><span class="line">       return -1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回v本身，不会影响该数组本身（我理解是为深拷贝）</span><br><span class="line">    * @return a clone of this &lt;tt&gt;ArrayList&lt;&#x2F;tt&gt; instance</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Object clone() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           ArrayList&lt;?&gt; v &#x3D; (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">           v.elementData &#x3D; Arrays.copyOf(elementData, size);</span><br><span class="line">           v.modCount &#x3D; 0;</span><br><span class="line">           return v;</span><br><span class="line">       &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">           &#x2F;&#x2F; this shouldn&#39;t happen, since we are Cloneable</span><br><span class="line">           throw new InternalError(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回包含该数组元素的新数组（深拷贝）</span><br><span class="line">    * @return an array containing all of the elements in this list in</span><br><span class="line">    *         proper sequence</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public Object[] toArray() &#123;</span><br><span class="line">       return Arrays.copyOf(elementData, size);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回指定运行类型的数组</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">   public &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">       if (a.length &lt; size)</span><br><span class="line">           &#x2F;&#x2F; Make a new array of a&#39;s runtime type, but my contents:</span><br><span class="line">           return (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">       System.arraycopy(elementData, 0, a, 0, size);</span><br><span class="line">       if (a.length &gt; size)</span><br><span class="line">           a[size] &#x3D; null;</span><br><span class="line">       return a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Positional Access Operations</span><br><span class="line"></span><br><span class="line">   @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">   E elementData(int index) &#123;</span><br><span class="line">       return (E) elementData[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 返回指定索引的元素</span><br><span class="line">    * @param  index index of the element to return</span><br><span class="line">    * @return the element at the specified position in this list</span><br><span class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public E get(int index) &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       return elementData(index);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 设置指定索引位置的元素</span><br><span class="line">    * @param index index of the element to replace</span><br><span class="line">    * @param element element to be stored at the specified position</span><br><span class="line">    * @return the element previously at the specified position</span><br><span class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public E set(int index, E element) &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       E oldValue &#x3D; elementData(index);</span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 添加元素</span><br><span class="line">    * @param e element to be appended to this list</span><br><span class="line">    * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean add(E e) &#123;</span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">       elementData[size++] &#x3D; e;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 在指定位置插入元素</span><br><span class="line">    * @param index index at which the specified element is to be inserted</span><br><span class="line">    * @param element element to be inserted</span><br><span class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void add(int index, E element) &#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!</span><br><span class="line">       System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                        size - index);</span><br><span class="line">       elementData[index] &#x3D; element;</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 删除索引指定元素，索引后的元素整体往左移动一个元素</span><br><span class="line">    * @param index the index of the element to be removed</span><br><span class="line">    * @return the element that was removed from the list</span><br><span class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public E remove(int index) &#123;</span><br><span class="line">       rangeCheck(index);</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       E oldValue &#x3D; elementData(index);</span><br><span class="line"></span><br><span class="line">       int numMoved &#x3D; size - index - 1;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line"></span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 删除指定元素，被删除元素后的整体往左移动一个元素</span><br><span class="line">    *</span><br><span class="line">    * @param o element to be removed from this list, if present</span><br><span class="line">    * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if this list contained the specified element</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean remove(Object o) &#123;</span><br><span class="line">       if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">           for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">               if (elementData[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">               if (o.equals(elementData[index])) &#123;</span><br><span class="line">                   fastRemove(index);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;*</span><br><span class="line">    * Private remove method that skips bounds checking and does not</span><br><span class="line">    * return the value removed.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private void fastRemove(int index) &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       int numMoved &#x3D; size - index - 1;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                            numMoved);</span><br><span class="line">       elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 清除列表全部元素</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void clear() &#123;</span><br><span class="line">       modCount++;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">       for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">           elementData[i] &#x3D; null;</span><br><span class="line"></span><br><span class="line">       size &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 从尾部开始将指定集合插入进列表</span><br><span class="line">    *</span><br><span class="line">    * @param c collection containing elements to be added to this list</span><br><span class="line">    * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if this list changed as a result of the call</span><br><span class="line">    * @throws NullPointerException if the specified collection is null</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       Object[] a &#x3D; c.toArray();</span><br><span class="line">       int numNew &#x3D; a.length;</span><br><span class="line">       ensureCapacityInternal(size + numNew);  &#x2F;&#x2F; Increments modCount</span><br><span class="line">       System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">       size +&#x3D; numNew;</span><br><span class="line">       return numNew !&#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 从指定索引开始将指定集合插入进列表</span><br><span class="line">    * @param index index at which to insert the first element from the</span><br><span class="line">    *              specified collection</span><br><span class="line">    * @param c collection containing elements to be added to this list</span><br><span class="line">    * @return &lt;tt&gt;true&lt;&#x2F;tt&gt; if this list changed as a result of the call</span><br><span class="line">    * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125;</span><br><span class="line">    * @throws NullPointerException if the specified collection is null</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">       rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">       Object[] a &#x3D; c.toArray();</span><br><span class="line">       int numNew &#x3D; a.length;</span><br><span class="line">       ensureCapacityInternal(size + numNew);  &#x2F;&#x2F; Increments modCount</span><br><span class="line"></span><br><span class="line">       int numMoved &#x3D; size - index;</span><br><span class="line">       if (numMoved &gt; 0)</span><br><span class="line">           System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                            numMoved);</span><br><span class="line"></span><br><span class="line">       System.arraycopy(a, 0, elementData, index, numNew);</span><br><span class="line">       size +&#x3D; numNew;</span><br><span class="line">       return numNew !&#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br></pre></td></tr></table></figure>

<h3 id="System-arraycopy-和Arrays-copyOf"><a href="#System-arraycopy-和Arrays-copyOf" class="headerlink" title="System.arraycopy()和Arrays.copyOf"></a>System.arraycopy()和Arrays.copyOf</h3><blockquote>
<p>在ArrayList类中add操作和remove的时候都用到了System.arraycopy（）方法来控制数组元素的移动</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</span><br></pre></td></tr></table></figure>



<blockquote>
<p> src:源数组；<br>  srcPos:源数组要复制的起始位置；<br>  dest:目的数组；<br>  destPos:目的数组放置的起始位置；<br>  length:复制的长度。<br>  注意：src and dest都必须是同类型或者可以进行转换类型的数组．</p>
</blockquote>
<blockquote>
<p>在toArray方法中通过Arrays.copyOf()方法在转换成数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T[] copyOf(T[] original, int newLength)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>original:要复制的数组<br> newLength:复制的长度</p>
</blockquote>
<h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><blockquote>
<p>1.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置<br>    2.copyOf()是系统自动在内部新建一个数组，并返回该数组。</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList.md" target="_blank" rel="noopener">ArrayList源码分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">我的第一次博客</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-18 14:04:00 / Modified: 19:28:13" itemprop="dateCreated datePublished" datetime="2020-04-18T14:04:00+08:00">2020-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始于2020年4月18日</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
