<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="陈梓佳的学习笔记~">
<meta property="og:type" content="website">
<meta property="og:title" content="汤姆猫的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="汤姆猫的博客">
<meta property="og:description" content="陈梓佳的学习笔记~">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="陈梓佳">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>汤姆猫的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
	<a href="https://github.com/chenzijia12300" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">汤姆猫的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-主页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-档案">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>档案</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/27/lasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/27/lasticsearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Elasticsearch学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-27 22:02:00" itemprop="dateCreated datePublished" datetime="2020-06-27T22:02:00+08:00">2020-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-28 00:08:46" itemprop="dateModified" datetime="2020-06-28T00:08:46+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Elasticsearch/" itemprop="url" rel="index"><span itemprop="name">Elasticsearch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="啥是Elasticsearch"><a href="#啥是Elasticsearch" class="headerlink" title="啥是Elasticsearch"></a>啥是Elasticsearch</h3><blockquote>
<p>ElasticSearch是一个高度可扩展的开源搜索引擎并使用REST API，底层是开源库 Lucene。</p>
</blockquote>
<h3 id="Elasticsearch优点"><a href="#Elasticsearch优点" class="headerlink" title="Elasticsearch优点"></a>Elasticsearch优点</h3><ul>
<li>横向可扩展性: 作为大型分布式集群，很容易就能扩展新的服务器到ES集群中；也可运行在单机上作为轻量级搜索引擎使用。</li>
<li>更丰富的功能: 与传统关系型数据库相比，ES提供了全文检索、同义词处理、相关度排名、复杂数据分析、海量数据的近实时处理等功能。</li>
<li>高可用: 提供副本(Replica)机制，一个分片可以设置多个副本，即使在某些服务器宕机后，集群仍能正常工作。</li>
<li>开箱即用: 提供简单易用的 API，服务的搭建、部署和使用都很容易操作。</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="Node与Cluster"><a href="#Node与Cluster" class="headerlink" title="Node与Cluster"></a>Node与Cluster</h4><p>Elasticsearch本质上是一个分布式的数据库，它可以多台服务器协同工作，运行多个多个实例。<br><strong><em>单个实例被称为一个节点（Node），一组节点就被成为Cluster</em></strong></p>
<h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>
<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><p><img src="/images/pasted-75.png" alt="upload successful"></p>
<p><img src="/images/pasted-76.png" alt="upload successful"></p>
<p><img src="/images/pasted-77.png" alt="upload successful"></p>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/26/ocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/26/ocker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Docker学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-26 22:02:00" itemprop="dateCreated datePublished" datetime="2020-06-26T22:02:00+08:00">2020-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-27 21:45:43" itemprop="dateModified" datetime="2020-06-27T21:45:43+08:00">2020-06-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">容器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h3><blockquote>
<p>Docker 是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。</p>
</blockquote>
<h3 id="使用Docker好处"><a href="#使用Docker好处" class="headerlink" title="使用Docker好处"></a>使用Docker好处</h3><h4 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h4><p>虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台(软件, 系统), Docker在降低额外开销的情况下提供了同样的功能. 它能让你将运行环境和配置放在代码汇总然后部署, 同一个Docker的配置可以在不同的环境环境中使用, 这样就降低了硬件要求和应用环境之间耦合度。</p>
<h4 id="代码流水线管理"><a href="#代码流水线管理" class="headerlink" title="代码流水线管理"></a>代码流水线管理</h4><p>代码从开发者的机器到最终在生产环境上的部署, 需要经过很多的中坚环境. 而每一个中间环境都有自己微小的差别, Docker给应用提供了一个从开发到上线均一致的环境, 让代码的流水线变得简单不少.</p>
<h4 id="提升开发效率"><a href="#提升开发效率" class="headerlink" title="提升开发效率"></a>提升开发效率</h4><p>开发者可以贴近生产环境，并可以快速搭建开发环境。Docker可以轻易的让几十个服务在Docker中跑起来。</p>
<h4 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h4><p>将一个整体式的应用拆分成低耦合的单个服务(微服务架构)</p>
<h3 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h3><h4 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h4><p>Docker镜像是一个特殊的文件系统，提供容器运行时所需的程序、库、资源、配置等文件，另外还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。<br>镜像是一个静态的概念，不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p>Docker的镜像是用于生成容器的模板，镜像分层的，镜像与容器的关系，就是面向对象编程中类与对象的关系，我们定好每一个类，然后使用类创建对象，对应到Docker的使用上，则是构建好每一个镜像，然后使用镜像创建我们需要的容器。</p>
<h4 id="仓库（Repository）"><a href="#仓库（Repository）" class="headerlink" title="仓库（Repository）"></a>仓库（Repository）</h4><p>用来存放和分发镜像的服务，Docker Hub就是Docker提供用于存储和分布镜像的官方Docker Registry，也是默认的Registry，其网址为<a href="https://hub.docker.com。" target="_blank" rel="noopener">https://hub.docker.com。</a></p>
<h3 id="Docker基本命令"><a href="#Docker基本命令" class="headerlink" title="Docker基本命令"></a>Docker基本命令</h3><h4 id="镜像常用命令"><a href="#镜像常用命令" class="headerlink" title="镜像常用命令"></a>镜像常用命令</h4><h5 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search java</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-73.png" alt="upload successful"></p>
<p>再上图的结果中共有5列，分别代表以下含义</p>
<ul>
<li>NAME:镜像仓库名称</li>
<li>DESCRIPTION:镜像仓库描述</li>
<li>STARS:镜像仓库收藏数，跟GitHub的stars一样一样的</li>
<li>OFFICAL:表示是否为官方仓库，该列标记为【OK】的镜像均由各软件的官方项目组创建和维护。</li>
<li>AUTOMATED:表示是否自动构建的镜像仓库</li>
</ul>
<h5 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull java</span><br></pre></td></tr></table></figure>
<p>执行该命令后，Docker会从Docker Hub中的java仓库下载最新版本的java镜像</p>
<h5 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>列出已下载的镜像</p>
<p><img src="/images/pasted-74.png" alt="upload successful"></p>
<p>上图的结果共有5列，分别代表以下含义</p>
<ul>
<li>REPOSITORY:镜像所属仓库名称</li>
<li>TAG:镜像标签，latest表示最新的</li>
<li>IMAGE ID: 镜像ID，表示镜像唯一标识</li>
<li>CREATED:镜像创建时间</li>
<li>SIZE:镜像大小</li>
</ul>
<h5 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h5><p>使用docker rmi命令即可删除指定镜像</p>
<h4 id="容器常用命令"><a href="#容器常用命令" class="headerlink" title="容器常用命令"></a>容器常用命令</h4><h5 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dokcer run 镜像名</span><br></pre></td></tr></table></figure>

<p>常见选项</p>
<ul>
<li>d:表示后台运行</li>
<li>P:随机端口映射</li>
<li>p:指定端口映射，有四种格式<ul>
<li>ip:hostPort:containerPort</li>
<li>ip::containerPort</li>
<li>hostPort:containerPort</li>
<li>containerPort</li>
</ul>
</li>
</ul>
<h5 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>上图的结果共有7列，分别代表以下含义</p>
<ul>
<li>CONTAINER_ID:表示容器ID</li>
<li>IMAGE:表示镜像名称</li>
<li>COMMAND:表示启动容器时运行的命令</li>
<li>CREATED:表示容器的创建时间</li>
<li>STATUS:表示容器运行状态，Up为运行中，Exited为停止</li>
<li>PORTS:表示容器对外的端口号</li>
<li>NAMES:表示容器名称</li>
</ul>
<h5 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop ContainerId</span><br></pre></td></tr></table></figure>

<h5 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill ContainerId</span><br></pre></td></tr></table></figure>
<h5 id="启动已停止的容器"><a href="#启动已停止的容器" class="headerlink" title="启动已停止的容器"></a>启动已停止的容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start ContainerId</span><br></pre></td></tr></table></figure>
<h5 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart</span><br></pre></td></tr></table></figure>

<h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm Container</span><br></pre></td></tr></table></figure>
<p><strong><em>小知识：该命令只能移除已停止的容器，如果需要移除正在运行的容器，可以使用-f参数</em></strong></p>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/24/sql%E4%B8%ADselect-update%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/24/sql%E4%B8%ADselect-update%E5%B9%B6%E5%8F%91%E7%9A%84%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">mysql中select+update并发的更新问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-24 10:44:00 / Modified: 16:25:41" itemprop="dateCreated datePublished" datetime="2020-06-24T10:44:00+08:00">2020-06-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index"><span itemprop="name">mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="小知识补充"><a href="#小知识补充" class="headerlink" title="小知识补充"></a>小知识补充</h3><p>首先，我们要知道在mysql中update操作都是线程安全的，mysql引擎会update的行加上<strong><em>排他锁</em></strong>，其他对该行的update操作需要等到第一个update操作提交成功或者回滚，才能获取这个<strong><em>排他锁</em></strong>，从而对该行进行操作。</p>
<h3 id="例子表结构"><a href="#例子表结构" class="headerlink" title="例子表结构"></a>例子表结构</h3><p><img src="/images/pasted-66.png" alt="upload successful"></p>
<p><strong><em>小知识点:表必备三字段：id, create_time, update_time。</em></strong><br>说明：其中id 必为主键，类型为bigint unsigned、单表时自增、步长为 1。create_time, update_time 的类型均为 datetime 类型。 (来自《阿里巴巴Java开发手册（华山版）》)</p>
<h3 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h3><ul>
<li>jdk1.8</li>
<li>idea</li>
<li>SpringBoot</li>
<li>Mybatis Plus</li>
</ul>
<h3 id="场景演示"><a href="#场景演示" class="headerlink" title="场景演示"></a>场景演示</h3><p>现在假设我们要写一个买书的代码（这里为了简单就一次卖一本啦），并使用线程池模拟并发开启30个线程去买20本书，那我们可以十分随意的写出这样的代码。</p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p><img src="/images/pasted-68.png" alt="upload successful"></p>
<h4 id="无锁更新"><a href="#无锁更新" class="headerlink" title="无锁更新"></a>无锁更新</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int decrGoodsAmount(long id) &#123;</span><br><span class="line">    QueryWrapper queryWrapper &#x3D; new QueryWrapper();</span><br><span class="line">    queryWrapper.eq(&quot;id&quot;,id);</span><br><span class="line">    queryWrapper.last(&quot;for update&quot;);</span><br><span class="line">    Goods goods &#x3D; baseMapper.selectOne(queryWrapper);</span><br><span class="line">    if (goods.getAmount()&gt;0)&#123;</span><br><span class="line">        UpdateWrapper updateWrapper &#x3D; new UpdateWrapper();</span><br><span class="line">        updateWrapper.setSql(&quot;amount&#x3D;amount-1&quot;);</span><br><span class="line">        updateWrapper.eq(&quot;id&quot;,id);</span><br><span class="line">        return baseMapper.update(null,updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="/images/pasted-69.png" alt="upload successful"></p>
<p>结果很明显超卖啦，虽然我们有使用if去判断库存，但是在并发情况下，你<strong><em>观察到的情况可能已经被改变啦</em></strong>。</p>
<h4 id="写独占锁更新"><a href="#写独占锁更新" class="headerlink" title="写独占锁更新"></a>写独占锁更新</h4><p>我们首先来了解一下 for update语法：</p>
<blockquote>
<p>for update是在数据库中上锁用的，可以为数据库中的行上一个排它锁。当一个事务的操作未完成时候，其他事务可以读取但是不能写入或更新。InnoDB默认是行级别的锁，当有明确指定的主键时候，是行级锁。否则是表级别。</p>
</blockquote>
<p><strong><em>小知识：for update 仅适用于InnoDB，并且必须开启事务，在begin与commit之间才生效。</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(isolation &#x3D; Isolation.READ_COMMITTED)</span><br><span class="line">public int decrGoodsAmountByLock(long id) &#123;</span><br><span class="line">    QueryWrapper queryWrapper &#x3D; new QueryWrapper();</span><br><span class="line">    queryWrapper.eq(&quot;id&quot;,id);</span><br><span class="line">    queryWrapper.last(&quot;for update&quot;);</span><br><span class="line">    Goods goods &#x3D; baseMapper.selectOne(queryWrapper);</span><br><span class="line">    if (goods.getAmount()&gt;0)&#123;</span><br><span class="line">        UpdateWrapper updateWrapper &#x3D; new UpdateWrapper();</span><br><span class="line">        updateWrapper.setSql(&quot;amount&#x3D;amount-1&quot;);</span><br><span class="line">        updateWrapper.eq(&quot;id&quot;,id);</span><br><span class="line">        return baseMapper.update(null,updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><p><img src="/images/pasted-70.png" alt="upload successful"></p>
<h4 id="CAS更新"><a href="#CAS更新" class="headerlink" title="CAS更新"></a>CAS更新</h4><p>除了使用独占锁或者说是悲观锁来控制数据并发安全，还有什么方法呢？我们还可以使用乐观锁CAS来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int decrGoodsAmountByCAS(long id) &#123;</span><br><span class="line">    QueryWrapper queryWrapper &#x3D; new QueryWrapper();</span><br><span class="line">    queryWrapper.eq(&quot;id&quot;,id);</span><br><span class="line">    int flag &#x3D; 0,num &#x3D; 0;</span><br><span class="line">    while (flag&#x3D;&#x3D;0) &#123;</span><br><span class="line">        if (++num&#x3D;&#x3D;3)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Goods goods &#x3D; baseMapper.selectOne(queryWrapper);</span><br><span class="line">        if (goods.getAmount() &gt; 0) &#123;</span><br><span class="line">            UpdateWrapper updateWrapper &#x3D; new UpdateWrapper();</span><br><span class="line">            updateWrapper.setSql(&quot;amount&#x3D;amount-1,update_time&#x3D;CURRENT_TIMESTAMP()&quot;);</span><br><span class="line">            updateWrapper.eq(&quot;id&quot;, id);</span><br><span class="line">            updateWrapper.eq(&quot;amount&quot;,goods.getAmount());</span><br><span class="line">            flag &#x3D; baseMapper.update(null, updateWrapper);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h5><p><img src="/images/pasted-71.png" alt="upload successful"></p>
<p><img src="/images/pasted-72.png" alt="upload successful"></p>
<p>我们可以看到在尝试3次后，任然有22个线程尝试失败，这是因为并发太过激烈的原因。那么什么时候使用CAS操作呢？</p>
<blockquote>
<p>阿里巴巴的开发规范上提到，在并发不高的情况下（尝试失败率不超过20%的情况下），推荐用CAS更新。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>使用独占锁来解决并发问题是不错，但我觉得不太常用。</li>
<li>使用CAS来解决并发问题也不错，甚至不用加事务，而且不会堵塞读取操作。</li>
</ul>
<ol>
<li>如果对读的响应度要求非常高，比如证券交易系统，那么适合用乐观锁，因为悲观锁会阻塞读</li>
<li>如果读远多于写，那么也适合用乐观锁，因为用悲观锁会导致大量读被少量的写阻塞</li>
<li>如果写操作频繁并且冲突比例很高，那么适合用悲观写独占锁</li>
</ol>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://www.jianshu.com/p/712b8da4c9d6" target="_blank" rel="noopener">简书</a></p>
<p><a href="https://segmentfault.com/q/1010000009454877" target="_blank" rel="noopener">思否</a></p>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/23/ava-BigDecimal%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/23/ava-BigDecimal%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">java BigDecimal详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-23 14:42:54 / Modified: 15:22:42" itemprop="dateCreated datePublished" datetime="2020-06-23T14:42:54+08:00">2020-06-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>首先我们都知道float和dobule会产生精度的问题，这是因为他们在设计时就是为了科学计算和工程计算，在广域数值范围上提供较为精确的快速近似计算而精心设计的。但是在商业计算中就不行啦，商业计算要求计算准确，精准,你想想，如果你的支付宝账户余额显示233.9999988888，那是一种怎么样的体验？这个时候BigDecimal就有用了。</p>
<p><img src="/images/pasted-62.png" alt="upload successful"></p>
<h3 id="BigDecimal构造方法"><a href="#BigDecimal构造方法" class="headerlink" title="BigDecimal构造方法"></a>BigDecimal构造方法</h3><ol>
<li>BigDecimal(int) </li>
<li><del>BigDecimal(double)</del></li>
<li>BigDecimal(long) </li>
<li><strong><em>BigDecimal(String)</em></strong></li>
</ol>
<p>BigDecimal共有四种构造方法，但是其中构造参数为double类型的构造方法不推荐使用，为啥呢？看下面。</p>
<p><img src="/images/pasted-63.png" alt="upload successful"></p>
<p>使用double类型的构造方法具有不确定性，使用string类型的构造方法就具有确定性，传的啥，创建啥。</p>
<h3 id="BigDecimal的四则运算"><a href="#BigDecimal的四则运算" class="headerlink" title="BigDecimal的四则运算"></a>BigDecimal的四则运算</h3><ol>
<li>public BigDecimal add(BigDecimal value)//加法</li>
<li>public BigDecimal subtract(BigDecimal value)//减法</li>
<li>public BigDecimal multiply(BigDecimal value)//乘法</li>
<li>public BigDecimal divide(BigDecimal value)//除法</li>
</ol>
<p><img src="/images/pasted-64.png" alt="upload successful"></p>
<p><strong><em>加减乘除其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象</em></strong></p>
<p>当divide除不尽的时候会抛出java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result异常。</p>
<p><img src="/images/pasted-65.png" alt="upload successful"></p>
<p>因此divide可以传三个参数</p>
<ul>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) </li>
</ul>
<ul>
<li>ROUND_UP ：向远离零的方向舍入。舍弃非零部分，并将非零舍弃部分相邻的一位数字加一。</li>
<li>ROUND_DOWN ：向接近零的方向舍入。舍弃非零部分，同时不会非零舍弃部分相邻的一位数字加一，采取截取行为。</li>
<li>ROUND_CEILING ：向正无穷的方向舍入。如果为正数，舍入结果同ROUND_UP一致；如果为负数，舍入结果同ROUND_DOWN一致。注意：此模式不会减少数值大小。</li>
<li>ROUND_FLOOR ：向负无穷的方向舍入。如果为正数，舍入结果同ROUND_DOWN一致；如果为负数，舍入结果同ROUND_UP一致。注意：此模式不会增加数值大小。</li>
<li>ROUND_HALF_UP ：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分&gt;= 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“四舍五入”。</li>
<li>ROUND_HALF_DOWN ：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向下舍入的舍入模式。如果舍弃部分&gt; 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“五舍六入”。</li>
<li>ROUND_HALF_EVEN ：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则相邻的偶数舍入。如果舍弃部分左边的数字奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意：在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况，如果前一位为奇数，则入位，否则舍去。</li>
<li>ROUND_UNNECESSARY ：断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>商业计算使用BigDecimal。</li>
<li>尽量使用参数类型为String的构造函数。</li>
<li>BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/Jason-Xiang/p/10220231.html" target="_blank" rel="noopener">Java BigDecimal详解</a></p>
<p><a href="https://blog.csdn.net/qq_35868412/article/details/89029288" target="_blank" rel="noopener">java 中 BigDecimal 详解</a></p>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">活动启动模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-16 21:15:00 / Modified: 21:21:23" itemprop="dateCreated datePublished" datetime="2020-06-16T21:15:00+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">android基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h3><h4 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h4><p>tandard是活动默认的启动模式，在不进行显式指定的情况下，所有活动都会自动使用这种启动模式。在standard模式（即默认情况）下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。</p>
<p><img src="/images/pasted-58.png" alt="upload successful"></p>
<h4 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h4><p>当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。不过当启动的活动并未处于栈顶位置时，这时再启动活动，还是会创建新的实例的。</p>
<p><img src="/images/pasted-59.png" alt="upload successful"></p>
<h4 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h4><p>当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。</p>
<p><img src="/images/pasted-60.png" alt="upload successful"></p>
<h4 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h4><p>待学，暂时用不到。</p>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">活动的生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-16 21:03:00 / Modified: 21:16:13" itemprop="dateCreated datePublished" datetime="2020-06-16T21:03:00+08:00">2020-06-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">android基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h3><h4 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h4><blockquote>
<p>Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下Back键或调用finish() 方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。</p>
</blockquote>
<p><img src="/images/pasted-56.png" alt="upload successful"></p>
<h4 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h4><p>活动在其生命周期最多会有4中状态</p>
<h5 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h5><p>当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处于运行状态的活动，因为这会带来非常差的用户体验。</p>
<h5 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h5><p>当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。系统也不愿意去回收这种活动（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种活动。</p>
<h5 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h5><p>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收。</p>
<h5 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h5><p>当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</p>
<h4 id="活动7种回调方法"><a href="#活动7种回调方法" class="headerlink" title="活动7种回调方法"></a>活动7种回调方法</h4><ul>
<li><p>onCreate()它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。</p>
</li>
<li><p>onStart() 。这个方法在活动由不可见变为可见的时候调用。</p>
</li>
<li><p>onResume() 。这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态。</p>
</li>
<li><p>onPause() 。这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶活动的使用。</p>
</li>
<li><p>onStop() 。这个方法在活动完全不可见的时候调用。它和onPause() 方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause() 方法会得到执行，而onStop() 方法并不会执行。</p>
</li>
<li><p>onDestroy() 。这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
</li>
<li><p>onRestart() 。这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p>
</li>
</ul>
<p><img src="/images/pasted-57.png" alt="upload successful"></p>
<h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h4><blockquote>
<p>Activity中还提供了一个onSaveInstanceState() 回调方法，这个方法可以保证在活动被回收之前一定会被调用，因此我们可以通过这个方法来解决活动被回收时临时数据得不到保存的问题。</p>
</blockquote>
<p>onSaveInstanceState() 方法会携带一个Bundle 类型的参数，Bundle 提供了一系列的方法用于保存数据，比如可以使用putString() 方法保存字符串，使用putInt() 方法保存整型数据，以此类推。每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle 中取值，第二个参数是真正要保存的内容。</p>
<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul>
<li>全来自《第一行代码——Android（第2版）》</li>
</ul>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/16/ava%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/ava%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">java类的加载机制(学习笔记)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-16 18:16:00" itemprop="dateCreated datePublished" datetime="2020-06-16T18:16:00+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-17 16:04:35" itemprop="dateModified" datetime="2020-06-17T16:04:35+08:00">2020-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="啥是类加载"><a href="#啥是类加载" class="headerlink" title="啥是类加载"></a>啥是类加载</h3><blockquote>
<p>类加载是指将class文件读入内存中，并对数据进行校验、转换解析、初始化，最后再<strong><em>堆区</em></strong>创建一个java.lang.Class对象，用来封装类在方法区的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
</blockquote>
<blockquote>
<p>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。</p>
</blockquote>
<p><strong><em>加载.class文件的方式</em></strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="/images/pasted-61.png" alt="upload successful"></p>
<p>类的加载过程包括了加载、验证、准备、解析、初始化这五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h4 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h4><p>加载阶段负责<strong><em>查找和加载类的二进制数据</em></strong>。</p>
<ol>
<li>通过类的<strong><em>全限定名</em></strong>来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ol>
<p><strong><em>小知识：加载阶段是可控性最强的阶段，我们可以自定义类加载器（ClassLoader）来完成类的加载。</em></strong></p>
<h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>验证阶段负责确保<strong><em>Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</em></strong>。</p>
<ul>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ul>
<p><strong><em>小知识:验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</em></strong></p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h4><p>准备阶段负责为<strong><em>类的静态变量分配内存（方法区），并将其初始化为默认值</em></strong>。<br>注意事项：</p>
<ol>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
<li>如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li>
</ol>
<p><strong><em>小知识：将static变量赋值为Java代码中被显式地赋予的值是在初始化阶段才会开始</em></strong></p>
<h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><p>解析阶段负责将<strong><em>类中的符号引用转换为直接引用</em></strong>，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<ul>
<li><strong><em>符号引用</em></strong>就是一组符号来描述目标，可以是任何字面量。</li>
<li><strong><em>直接引用</em></strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<h4 id="初始化（initialization）"><a href="#初始化（initialization）" class="headerlink" title="初始化（initialization）"></a>初始化（initialization）</h4><p>初始化阶段负责为为<strong><em>类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化</em></strong>，此阶段其实就是执行<strong><em>&lt;clinit&gt;()方法</em></strong>的过程。</p>
<ul>
<li><p>&lt;clinit&gt;() 不需要显式调用父类（接口除外，接口不需要调用父接口的初始化方法，只有使用到父接口中的静态变量时才需要调用）的初始化方法 &lt;clinit&gt;()，虚拟机会保证在子类的 &lt;clinit&gt;() 方法执行之前，父类的&lt;clinit&gt;() 方法已经执行完毕，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
</li>
<li><p>&lt;clinit&gt;()  方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 &lt;clinit&gt;() 方法。</p>
</li>
<li><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;() 方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。</p>
</li>
</ul>
<p><strong><em>类的初始化时机</em></strong></p>
<ul>
<li>创建类的实例</li>
<li>访问或者赋值某个类或者接口的静态变量</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化其子类，则该类也会被初始化</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>java语言自带三个类加载器</p>
<ul>
<li><p>Bootstrap ClassLoader(启动类加载器):负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p>
</li>
<li><p>Extention ClassLoader(扩展类加载器):该加载器sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>Application ClassLoader(应用程序类加载器):该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<blockquote>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
</blockquote>
<ol>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ol>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p><strong><em>为了保证java程序安全稳定运行</em></strong></p>
<ol>
<li><p>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p>
</li>
<li><p>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p>
</li>
<li><p>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载。</p>
</li>
<li><p>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
</li>
</ol>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/15/%E5%8D%95%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/15/%E5%8D%95%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">简单工程模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-15 21:20:00 / Modified: 21:40:53" itemprop="dateCreated datePublished" datetime="2020-06-15T21:20:00+08:00">2020-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简单工厂模式是创建形的设计模式，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先来个手机的接口（基类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建在 2020&#x2F;6&#x2F;15 18:31</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Phone &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 描述手机信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来几个手机具体类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class XiaoMiPhone implements Phone&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void info() &#123;</span><br><span class="line">        System.out.println(&quot;我是小米手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OppoPhone implements Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void info() &#123;</span><br><span class="line">        System.out.println(&quot;我是oppo手机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HuaWeiPhone implements Phone &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void info() &#123;</span><br><span class="line">        System.out.println(&quot;我是华为手机拉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在整个枚举类表示手机类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum PhoneType &#123;</span><br><span class="line">    XIAOMI(1),HUAWEI(2),OPPO(3);</span><br><span class="line"></span><br><span class="line">    private int code;</span><br><span class="line"></span><br><span class="line">    PhoneType(int code) &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所需要的配件都搞定拉，现在工厂启动！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BasePhoneFactory implements PhoneFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Phone produce(PhoneType type) &#123;</span><br><span class="line">        switch (type)&#123;</span><br><span class="line">            case XIAOMI:</span><br><span class="line">                return new XiaoMiPhone();</span><br><span class="line">            case OPPO:</span><br><span class="line">                return new OppoPhone();</span><br><span class="line">            case HUAWEI:</span><br><span class="line">                return new HuaWeiPhone();</span><br><span class="line">            default:</span><br><span class="line">                throw new AssertionError(&quot;没有该类型的手机&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PhoneFactory phoneFactory &#x3D; new BasePhoneFactory();</span><br><span class="line">        Phone phone &#x3D; phoneFactory.produce(PhoneType.XIAOMI);</span><br><span class="line">        phone.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<blockquote>
<p>我是小米手机</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>优点</li>
</ul>
<ol>
<li>便于对象的扩展，比如要创建苹果手机，只需要继承Phone接口即可，在工厂中对增加的类进行注册，既可以通过PhoneFactory来获取到增加的对象。</li>
<li>将同一类型的对象进行分装提取，共性都放在接口中，个性放在具体类中。</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>不利于不同类型对象的创建</li>
</ol>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-14 23:42:00" itemprop="dateCreated datePublished" datetime="2020-06-14T23:42:00+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-15 15:13:53" itemprop="dateModified" datetime="2020-06-15T15:13:53+08:00">2020-06-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>单例模式是java23中设计模式之一，也是最常见的一种模式。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>整个程序运行中只允许有一个类的实例</li>
<li>需要频繁创建然后销毁的对象</li>
<li>创建对象时耗时过多或者耗资源过多，但又经常用到的对象</li>
<li>方便资源相互通信的环境</li>
</ul>
<h3 id="单例的几种模式"><a href="#单例的几种模式" class="headerlink" title="单例的几种模式"></a>单例的几种模式</h3><h4 id="线程不安全的懒汉式"><a href="#线程不安全的懒汉式" class="headerlink" title="线程不安全的懒汉式"></a>线程不安全的懒汉式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton singleton;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @author czj</span><br><span class="line">     * 线程不安全懒汉式单例模式</span><br><span class="line">     * @date 2020&#x2F;6&#x2F;14 23:41</span><br><span class="line">     * @param []</span><br><span class="line">     * @return com.czj.design.Singleton</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (singleton&#x3D;&#x3D;null)&#123;</span><br><span class="line">            singleton &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在需要的时候才创建实例，节省内存空间，但是多线程同时访问会导致返回多个实例。</p>
</blockquote>
<h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建在 2020&#x2F;6&#x2F;14 23:38</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton singleton &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @author czj</span><br><span class="line">     * 饿汉式单例模式</span><br><span class="line">     * @date 2020&#x2F;6&#x2F;14 23:54</span><br><span class="line">     * @param []</span><br><span class="line">     * @return com.czj.design.Singleton</span><br><span class="line">     *&#x2F;</span><br><span class="line">     public static Singleton getInstance()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过JVM的类加载机制实现了初始化，保证了线程安全。</p>
</blockquote>
<h4 id="线程安全懒汉式"><a href="#线程安全懒汉式" class="headerlink" title="线程安全懒汉式"></a>线程安全懒汉式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建在 2020&#x2F;6&#x2F;14 23:38</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton singleton</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @author czj</span><br><span class="line">     * 线程安全懒汉式</span><br><span class="line">     * @date 2020&#x2F;6&#x2F;14 23:55</span><br><span class="line">     * @param []</span><br><span class="line">     * @return com.czj.design.Singleton</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if (singleton&#x3D;&#x3D;null)&#123;</span><br><span class="line">            synchronized (Singleton.class)&#123;</span><br><span class="line">                if (singleton&#x3D;&#x3D;null)&#123;</span><br><span class="line">                    singleton &#x3D; new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过双重加锁判断实现了线程安全，但是效率就慢了。</p>
</blockquote>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建在 2020&#x2F;6&#x2F;14 23:38</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Holder&#123;</span><br><span class="line">        public static Singleton singleton &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @author czj</span><br><span class="line">     * 静态内部类</span><br><span class="line">     * @date 2020&#x2F;6&#x2F;15 14:59</span><br><span class="line">     * @param []</span><br><span class="line">     * @return com.czj.design.Singleton</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return Holder.singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过JVM类加载机制保证线程安全。</p>
</blockquote>
<h4 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建在 2020&#x2F;6&#x2F;15 15:07</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public enum SingletonEnum &#123;</span><br><span class="line">    INSTANCE(new Object());</span><br><span class="line"></span><br><span class="line">    private Object object;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @author czj</span><br><span class="line">     * 枚举单例模式</span><br><span class="line">     * @date 2020&#x2F;6&#x2F;15 15:08</span><br><span class="line">     * @param [object]</span><br><span class="line">     * @return </span><br><span class="line">     *&#x2F;</span><br><span class="line">    SingletonEnum(Object object) &#123;</span><br><span class="line">        this.object &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过枚举方式创建的单例模式，能保证线程安全而且能防止序列化重新创建对象。</p>
</blockquote>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/14/ava7-try-with-resource/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈梓佳">
      <meta itemprop="description" content="陈梓佳的学习笔记~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤姆猫的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/ava7-try-with-resource/" class="post-title-link" itemprop="url">java7 try-with-resource</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-14 15:46:00 / Modified: 15:51:40" itemprop="dateCreated datePublished" datetime="2020-06-14T15:46:00+08:00">2020-06-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
      
          <h3 id="java7之前"><a href="#java7之前" class="headerlink" title="java7之前"></a>java7之前</h3><blockquote>
<p>在java7版本之前我们使用资源后，都需要把资源关闭，在try-catch-finally中的finally关闭资源。</p>
</blockquote>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">long currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">BufferedReader bufferedReader &#x3D; null;</span><br><span class="line">try&#123;</span><br><span class="line">    bufferedReader &#x3D; new BufferedReader(new FileReader(&quot;C:&#x2F;Users&#x2F;ZJ&#x2F;Desktop&#x2F;spring.log&quot;));</span><br><span class="line">    String line &#x3D; null;</span><br><span class="line">    while((line &#x3D; bufferedReader.readLine())!&#x3D;null)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println((System.currentTimeMillis()-currentTime)&#x2F;1000.0+&quot;秒&quot;);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    if (bufferedReader!&#x3D;null)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个代码莫得问题，但是太杂乱了，因此java7提供了一个新的语法糖：try-with-resource。</p>
</blockquote>
<h3 id="java7以后"><a href="#java7以后" class="headerlink" title="java7以后"></a>java7以后</h3><blockquote>
<p>try-with-resources 方式来管理资源，在try中声明资源，当程序执行完后，会自动将声明的资源关闭掉</p>
</blockquote>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">try(BufferedReader bufferedReader &#x3D; new BufferedReader(new FileReader(&quot;C:&#x2F;Users&#x2F;ZJ&#x2F;Desktop&#x2F;spring.log&quot;)))&#123;</span><br><span class="line">    String line &#x3D; null;</span><br><span class="line">    while((line &#x3D; bufferedReader.readLine())!&#x3D;null)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println((System.currentTimeMillis()-currentTime)&#x2F;1000.0+&quot;秒&quot;);</span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们可以很明显的看到代码量少了很多，而且再也不会因为忘记close而导致出问题拉。</p>
</blockquote>

      
    </div>

    
    
    
		<div>
			
		</div>
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">陈梓佳</p>
  <div class="site-description" itemprop="description">陈梓佳的学习笔记~</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈梓佳</span>
</div>
<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
